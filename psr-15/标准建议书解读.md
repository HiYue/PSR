### PSR-15建议书的解读

#### 为什么会有PSR-15的出现

对于HTTP Request对象的处理，是任何一个 Web/API 应用程序都必须要面对的问题，但是却没有一个确定的参考规范，来约束如何实现对`HTTP Request`进行操作的消息处理器和中间件类。

- 中间件：在PHP生态中已经存在并使用了多年，[StackPHP](https://stackphp.com/) 提出了一个可复用的中间件模块的通用模型。自从 PSR 提出了 `HTTP Message` 接口建议以来，众多的PHP框架已经基于`HTTP Message`各自实现了中间件模块
- 遵从上面的标准而开发的中间件接口库，为`HTTP Request`带来了如下的好处:
    - 为开发人员提供正式标准 (**使用这些库、方法的时候非常的方便**)
    - 允许任何中间件组件在任何兼容框架中运行 (**中间件库可以独立开发，并在其他框架中被使用**)
    - 消除了在不同框架中，被重复定义的类似接口
    - 避免方法的声明中的微小差异 (**比如参数名称、类型、返回值类型等**)

---
#### PSR-15 建议书包含的内容
##### 涉及的问题

- 创建 "HTTP消息的请求处理程序" 的接口规范
- 创建 "HTTP消息的中间件" 的接口规范
- 基于最佳实践，按照 "请求处理程序 & 中间件的规范" 来实现这两个组件
- 确保 "请求处理程序 & 中间件" 与`HTTP Message`规范的任何实现都可以兼容

##### 不涉及的问题

- 尝试定义如何创建HTTP响应的机制
- 尝试为客户端/异步中间件定义接口
- 试图定义如何转发中间件

---
#### "请求处理程序"组件的实现

不同的应用场景可能导致 `Request Handler` 有多重的用途，`Request Handler`组件也被很多开发人员实现了很多次。但是无论思路有多么的不同，它们针对 `HTTP Message` 的处理过程都是一样的：
- 给定HTTP请求，为该请求生成HTTP响应。

---
#### "中间件"组件的实现

目前有两种使用HTTP消息的中间件的常用方法：
##### 双向通道

这是大多数中间件的实现库使用的方法定义，基于 `Express middleware` [官方链接](http://expressjs.com/en/guide/writing-middleware.html) 的实现思路，定义如下：
```php
fn(request, response, next): response
```

基于已采用此定义的中间件实现，可以观察到以下共性：
- 中间件被定义为可调用的。
- 中间件在调用期间传入3个参数：
    - ServerRequestInterface 接口的对象
    - ResponseInterface 接口的对象。
    - 一个callable，它接收请求和响应委托给下一个中间件

业界已经有大量的实现库。这种方法通常被称为“双通”，指的是传递给中间件的参数中包括了 `请求` 和 `响应`.

###### 框架项目举例
- mindplay/middleman v1
- relay/relay v1
- slim/slim v3
- zendframework/zend-stratigility v1
  
###### 中间件库举例
* bitexpert/adroit
* akrabat/rka-ip-address-middleware
* akrabat/rka-scheme-and-host-detection-middleware
* bear/middleware
* los/api-problem
* los/los-rate-limit
* monii/monii-action-handler-psr7-middleware
* monii/monii-nikic-fast-route-psr7-middleware
* monii/monii-response-assertion-psr7-middleware
* mtymek/blast-base-url
* ocramius/psr7-session
* oscarotero/psr7-middlewares
* php-middleware/block-robots
* php-middleware/http-authentication
* php-middleware/log-http-messages
* php-middleware/maintenance
* php-middleware/phpdebugbar
* php-middleware/request-id
* relay/middleware

> 这个接口的主要缺点是，当中间件接口对象，本身是可调用的时，目前没有办法确定闭包参数 `callable`的类型

##### 单向通道 (Lambda)

这是另外一种中间件的实现库的方法定义，基于 `StackPHP`的风格，定义如下：
```php
fn(request, next): response
```

基于已采用此定义的中间件实现，可以观察到以下共性：
- 中间件接口定义中所包含的 `HTTP Request` 参数，用来做进一步的处理
- 中间件在调用期间传入2个参数：
    - HTTP Request message 接口的对象
    - 中间件可以委派另一个`Request Handler` 生成HTTP响应消息

在这种形式中，中间件自身，在请求处理程序生成响应对象之前无法访问响应的。 在得到响应对象之后，中间件可以在修改响应之后再返回。

###### 使用单通方式实现中间件的项目

- 使用这种方式的项目不多，但是却包含大名鼎鼎的 [Guzzle](http://docs.guzzlephp.org/en/latest/handlers-and-middleware.html), _我想不会是由于Guzzle过于优秀，大家觉得够了，不需要再浪费精力了吧_。

```
// Guzzle的middleware的接口定义
function (RequestInterface $request, array $options): ResponseInterface
```

- 基于 Symfony HttpKernel 的StackPHP也是单向通道的，定义如下:
```
// StackPHP的middleware的接口定义, 注意是没有 response 参数的
function handle(Request $request, $type, $catch): Response
```

- 基于 Symfony 组件的 Laravel middleware也是其中之一, 定义如下
```
// Laravel的middleware的接口定义
function handle(Request $request, callable $next): Response
```